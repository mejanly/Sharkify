Need to implement SharkVertex
   1. Each vertex from the aobj has a SharkVertex
   2. The shark vertex has the coords probably and a vector of the bone weights
   3. For each bone weight, transform the vertex coords by the bone weight matrix
   4. Apparently this is all done by push/popping matrices from ONE Rendering Helper
   5. Do it, squid


According to sensei: 
   ONE Rendering Helper for the entire model composed of other matrices
      multiplied together
   But only one matrix is used at a time...
   (See below)
   
1) you shouldn’t need a render helper for each segment
2) each vertex is just transformed by one matrix - that matrix will be a 
   composite of multiple matrices multiplied together (which will be different 
   for each vertex but at any given time you only need one matrix - so one 
   matrix stack for the whole model should be enough) - perhaps think about it as
      a) before each animation frame
      b) for each vertex:
         create its composite matrix (which will be summing the weighted transform matrices for all bones)
         transform that vertex by that matrix
   
You can think of it that each vertex does have a different matrix

But you only need the matrix while you are transforming that vertex, so yes you can for example make the matrix for Frame0 for vertex0, multiple by it and then throw it away (and yes using push and pop)

Now, in terms of making the matrix for a given Vertex, lets say vertex_10 should be transformed by 1/2 the matrix in bone2 and 1/2 the matrix in bone3
prior to drawing vertex_10, say for frame 20, you need to look up the matrix for bone2 and bone3 at frame 20 and sum them together each weighted by 1/2 and then draw the transformed vertex.

Thus for each vertex you do need to know what the weights are for every bone
And for each bone you do need an array (collection) of transform matrices for every frame)
   
   
NO-- 
   1. Load all skin vertices into a bone-controlled matrix...
   2. For each bone, have a Rendering Helper for the combTrans
         combTrans responsible for posing the bone relative
            to the character...
         Not sure what the localTrans should be yet...
            To quote below, "responsible for rotating
               the bone in bone space"
   3. Apply transforms to the combTrans (maybe also the local trans)
   4. Draw vertices for each bone based on the RH

   5. Somehow....bone weights


Local transform
   The local transform is responsible for rotating B in bone space
      about its joint (Figure 2a), and also for offsetting (translating) B relative to its immediate
      parent such that B’s joint will connect with its parent bone (Figure 2b).
   The local transform of a bone offsets a bone relative to its parent

Combined transform
   In contrast to the local transform, the combined transform is responsible for
      actually posing the bone relative to the character in order to construct the character’s
      skeleton, as Figure 3 shows. In other words, the combined transform transforms a bone
      from bone space to the character space. Therefore, it follows that the combined
      transform is the transform that is used to actually positions and shapes the skin in
      character space. 
      
A bone's combined transform is
   determined by first applying its local transform (rotation followed by translation), then by
   applying the local transform of its parent P’ (note: P?), then by applying the local transform of its
   grandparent P’, ..., and finally by applying the local transform of its eldest parent P(n)
   (the root). 
   
Bone Struct:
   Name
   transform matrix
   sibling
   first child
   combined transform?

We never interpolate matrices because matrix rotations do not interpolate
   correctly—we must use quaternions to interpolate rotations correctly. Therefore,
   keyframe transformation data is usually always stored by a rotation quaternion, scaling
   vector, and translation vector (RST-values), and not as a matrix. After interpolating the
   RST-values (i.e., interpolating rotation quaternions, scaling vectors, and translation
   vectors) for all bones, we can proceed to build the bone-matrix for each bone out of the
   interpolated RST-values. Lastly, in the case a file format does present keyframe data as a
   matrix, we must decompose the matrix into RST-values in order to perform the
   interpolation. 
   
The position of the vertices near the joint are determined by a weighted average of the
   two influential bone transformations.

In vertex blending, we define the character’s skin as one continuous mesh in
   character space. Consequently, because the vertices are not in bone space, we cannot
   simply use the combined transforms of the bones.
To solve this, we introduce a new transform called the offset transform. Each
   bone in the skeleton has a corresponding offset matrix. An offset matrix transforms
   vertices, in the bind pose, from bind space to the space of the respective bone. 
   
Thus, by transforming the vertices by the offset matrix of some bone B, we move
   the vertices to the bone space of B. But once we have the vertices in bone space of B we
   can use B’s combined transform to position it back in character space in its current
   animated pose! So we now introduce a new transform, call it the final transform, which
   combines a bone’s offset transform with its combined transform. 
   F = MC (M is the offset matrix and C is the combined matrix)
   
Then the final position v′of any vertex v can be calculated with: (Page 14 eq near top)


----


Any new animated transformation on the bone has to be multiplied by the inverse of the bindpose matrix

