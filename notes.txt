THE FIRST ORDER OF BUSINESS: Traverse the tree better? Like, start at
   the root maybe and then go to the children, then its children...
   Need recursion

Move to right location, push, transform, draw, pop


  
So...the local transform just positions the bone, and the combined transform
   rotates (or transforms, w/e) it. 
The local transform is a vector and a matrix right now... 
The combined transform is just a matrix (rendering helper...a separate one from 
   the one that draws the skin...will need to fix this). 
The local matrix is transformed by the boneVec which is determined by the head and 
   tail points. I was using her equation, which I don't understand, so maybe I 
   should stop, but also the local transform is technically not doing anything at
   the moment so maybe it's fine.
THE ONLY THING DETERMINING THE POSITION OF THE BONES RIGHT NOW is the head and 
   tail points.

Maybe need to think of a new way to set up the bone matrices...

OKAY: It is possible to rotate THE ENTIRE BONE SETUP by modifying the Rendering
   Helper in SharkMesh->drawSkeleton... This implies that if I set up a Keyframe
   System and actually modify the bone matrices, push/pop them from the Rendering
   Helper matrix stack, then draw each individual bone, the bones will move as I 
   want them to.
   
Involved in this: 
   I think you would need to order the matrices in a certain way OR be able to
      look up which one should go next, since the matrices are pushing/popping
   But since the bones all have parents/children, maybe it's just a matter of
      pushing/popping the parents/children in the right way...
   So like, modify a matrix, then modify and push the child matrices??
   Have a vector of all childbones...so per bone, modify the matrix......
   The point of the tree might not be to reduce the number of transforms needed
      per bone, but to have an easier way to access each transform... ??
   
   
   
   
   

Not sure if the bone weights (next to the vertices on each vertex) are actually
   being read into some kind of data structure. Need to start creating
   SharkVertex structures with the bone weights in them. SharkVertex is already
   (mostly) implemented so I think I just need to...use it. Not sure about
   the vec3s as the storage type. 
   
Anyway... The matrices are supposed to be per vertex, per frame. 
There is a transform matrix for each bone per frame. To get the one for each
   vertex per frame, you multiply the applicable bone matrices by the bone
   weights and (literally) sum them together. So, .5*Spine1 + .5*Spine2,
   for example.
The matrices on the RenderingHelper stack have got to be the transform
   matrices per bone.








Local transform
   The local transform is responsible for rotating B in bone space
      about its joint (Figure 2a), and also for offsetting (translating) B relative to its immediate
      parent such that B’s joint will connect with its parent bone (Figure 2b).
   The local transform of a bone offsets a bone relative to its parent

Combined transform
   In contrast to the local transform, the combined transform is responsible for
      actually posing the bone relative to the character in order to construct the character’s
      skeleton, as Figure 3 shows. In other words, the combined transform transforms a bone
      from bone space to the character space. Therefore, it follows that the combined
      transform is the transform that is used to actually position and shape the skin in
      character space. 
      
A bone's combined transform is
   determined by first applying its local transform (rotation followed by translation), then by
   applying the local transform of its parent P’ (note: P?), then by applying the local transform of its
   grandparent P’, ..., and finally by applying the local transform of its eldest parent P(n)
   (the root). 
   
Bone Struct:
   Name
   transform matrix
   sibling
   first child
   combined transform?

We never interpolate matrices because matrix rotations do not interpolate
   correctly—we must use quaternions to interpolate rotations correctly. Therefore,
   keyframe transformation data is usually always stored by a rotation quaternion, scaling
   vector, and translation vector (RST-values), and not as a matrix. After interpolating the
   RST-values (i.e., interpolating rotation quaternions, scaling vectors, and translation
   vectors) for all bones, we can proceed to build the bone-matrix for each bone out of the
   interpolated RST-values. Lastly, in the case a file format does present keyframe data as a
   matrix, we must decompose the matrix into RST-values in order to perform the
   interpolation. 
   
The position of the vertices near the joint are determined by a weighted average of the
   two influential bone transformations.

In vertex blending, we define the character’s skin as one continuous mesh in
   character space. Consequently, because the vertices are not in bone space, we cannot
   simply use the combined transforms of the bones.
To solve this, we introduce a new transform called the offset transform. Each
   bone in the skeleton has a corresponding offset matrix. An offset matrix transforms
   vertices, in the bind pose, from bind space to the space of the respective bone. 
   
Thus, by transforming the vertices by the offset matrix of some bone B, we move
   the vertices to the bone space of B. But once we have the vertices in bone space of B we
   can use B’s combined transform to position it back in character space in its current
   animated pose! So we now introduce a new transform, call it the final transform, which
   combines a bone’s offset transform with its combined transform. 
   F = MC (M is the offset matrix and C is the combined matrix)
   
Then the final position v′of any vertex v can be calculated with: (Page 14 eq near top)


----


Any new animated transformation on the bone has to be multiplied by the inverse of the bindpose matrix

