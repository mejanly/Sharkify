THE FIRST ORDER OF BUSINESS: 
   What about a stack for bones? Hmm.
   
   Or create an actual tree struct with parent, child, and siblings...
      I've been thinking about this since the beginning...it might be time
         to actually do it...
   Perhaps keep an array of top-level bones to recurse through their children?
      What about siblings? Does that complicate things too much? Do we need
         siblings? The original code just uses child bones (as one vector)...
         But then I guess since they are just in a vector the "children" are
         siblings to each other?
   So a tree node has a parent and children which are siblings to each other?
   
   Back to the stack idea: Instead of an array, push on the stack each top-level
      bone? Would that work...?   




   What is a sustainable way to store bone transform matrices?
   Should the drawing all be done in SharkMesh? Should there be
      wrapper functions?
         Keyframe probably doesn't make sense. SharkVertex might
            make sense once it's implemented correctly. Maybe still
            SharkMesh for the bones. SharkBone even?? Hmm. If the
            RH is sent to each SharkBone as a pointer and you push
            the matrices that way??? Uhhh.
   Need to be able to push matrix, transform, draw, and pop in that
      order with the bones drawing in the correct order as well.
         It might make sense to create some kind of function for 
            traversing the bones in the appropriate order from X
            bone, like start at Spine4 and draw down the line...
               But if it's just recursing through you should only
                  need to start at a few bones and recurse down.
               Another problem is some of the hierarchy will need
                  to go in reverse order because the top half of
                  the shark's body will wiggle in the opposite
                  direction from the lower half of the shark's body.
               Perhaps it would make sense to build a vector (or linked
                  list? unsure of what would be an appropriate data 
                  structure but it would need to be something that goes
                  in one order) given a direction (like left, right, up
                  down).

Maybe I'm getting too ahead of myself.
For now... Just figure out how to store each bone matrix. So there's one
   transform matrix per bone. Load that matrix and draw the bone.

SharkBone->createOrder? Or just hard-code the orders in? That might be better.
   Then I can save different orders for different transforms and have a 
   switchOrder function that just changes which order we're using. Maybe
   in Keyframe. This involves knowing the order the bones are supposed to
   be in though...weh. For now could just take the Spine4 and add that and all 
   the other bones that aren't children of Spine4...meaning some bones won't be
   in the order. So maybe instead of createOrder it would be chooseBones.
If you have all the bones + Spine4 - Spine4's children... Once you get to Spine4
   you could draw separately, pushing and popping each child's matrix? You don't 
   need to push the matrices of the other bones.


make funcs for get head/tail vec4
move the rest of this to sharkmesh?
Put the matrix stack in sharkmesh...but send it here
   push from this func, pop from sharkmesh?
   need to be able to push the current bone...not just bones
      in order
   separate rendering helpers for shark bones and shark mesh for now?
      eventually they will be the same because we're only storing
         the different matrices for each bone, and the matrices
         for the individual vertices will be calculated intermittently



So... Things draw like an accordian?
   Look at SharkMesh (added yRot in so that could be doing stuff).
   Also made it so the children are modified by the same angle (probable
      culprit).
   The culprit is the if/else in SharkMesh->drawSkeleton... I think. Because
      the child bones fall under the 'else' category.

Move to right location, push, transform, draw, pop



The local transform just positions the bone, and the combined transform
   rotates (or transforms, w/e) it. 
The local transform is a vector and a matrix right now... 
The combined transform is just a matrix (rendering helper...a separate one from 
   the one that draws the skin...will need to fix this). 
The local matrix is transformed by the boneVec which is determined by the head and 
   tail points. I was using her equation, which I don't understand, so maybe I 
   should stop, but also the local transform is technically not doing anything at
   the moment so maybe it's fine.
THE ONLY THING DETERMINING THE POSITION OF THE BONES RIGHT NOW is the head and 
   tail points.

Maybe need to think of a new way to set up the bone matrices...

OKAY: It is possible to rotate THE ENTIRE BONE SETUP by modifying the Rendering
   Helper in SharkMesh->drawSkeleton... This implies that if I set up a Keyframe
   System and actually modify the bone matrices, push/pop them from the Rendering
   Helper matrix stack, then draw each individual bone, the bones will move as I 
   want them to.
   
Involved in this: 
   I think you would need to order the matrices in a certain way OR be able to
      look up which one should go next, since the matrices are pushing/popping
   But since the bones all have parents/children, maybe it's just a matter of
      pushing/popping the parents/children in the right way...
   So like, modify a matrix, then modify and push the child matrices??
   Have a vector of all childbones...so per bone, modify the matrix......
   The point of the tree might not be to reduce the number of transforms needed
      per bone, but to have an easier way to access each transform... ??
   
   
   
   
   

Not sure if the bone weights (next to the vertices on each vertex) are actually
   being read into some kind of data structure. Need to start creating
   SharkVertex structures with the bone weights in them. SharkVertex is already
   (mostly) implemented so I think I just need to...use it. Not sure about
   the vec3s as the storage type. 
   
Anyway... The matrices are supposed to be per vertex, per frame. 
There is a transform matrix for each bone per frame. To get the one for each
   vertex per frame, you multiply the applicable bone matrices by the bone
   weights and (literally) sum them together. So, .5*Spine1 + .5*Spine2,
   for example.
The matrices on the RenderingHelper stack have got to be the transform
   matrices per bone.








Local transform
   The local transform is responsible for rotating B in bone space
      about its joint (Figure 2a), and also for offsetting (translating) B relative to its immediate
      parent such that B’s joint will connect with its parent bone (Figure 2b).
   The local transform of a bone offsets a bone relative to its parent

Combined transform
   In contrast to the local transform, the combined transform is responsible for
      actually posing the bone relative to the character in order to construct the character’s
      skeleton, as Figure 3 shows. In other words, the combined transform transforms a bone
      from bone space to the character space. Therefore, it follows that the combined
      transform is the transform that is used to actually position and shape the skin in
      character space. 
      
A bone's combined transform is
   determined by first applying its local transform (rotation followed by translation), then by
   applying the local transform of its parent P’ (note: P?), then by applying the local transform of its
   grandparent P’, ..., and finally by applying the local transform of its eldest parent P(n)
   (the root). 
   
Bone Struct:
   Name
   transform matrix
   sibling
   first child
   combined transform?

We never interpolate matrices because matrix rotations do not interpolate
   correctly—we must use quaternions to interpolate rotations correctly. Therefore,
   keyframe transformation data is usually always stored by a rotation quaternion, scaling
   vector, and translation vector (RST-values), and not as a matrix. After interpolating the
   RST-values (i.e., interpolating rotation quaternions, scaling vectors, and translation
   vectors) for all bones, we can proceed to build the bone-matrix for each bone out of the
   interpolated RST-values. Lastly, in the case a file format does present keyframe data as a
   matrix, we must decompose the matrix into RST-values in order to perform the
   interpolation. 
   
The position of the vertices near the joint are determined by a weighted average of the
   two influential bone transformations.

In vertex blending, we define the character’s skin as one continuous mesh in
   character space. Consequently, because the vertices are not in bone space, we cannot
   simply use the combined transforms of the bones.
To solve this, we introduce a new transform called the offset transform. Each
   bone in the skeleton has a corresponding offset matrix. An offset matrix transforms
   vertices, in the bind pose, from bind space to the space of the respective bone. 
   
Thus, by transforming the vertices by the offset matrix of some bone B, we move
   the vertices to the bone space of B. But once we have the vertices in bone space of B we
   can use B’s combined transform to position it back in character space in its current
   animated pose! So we now introduce a new transform, call it the final transform, which
   combines a bone’s offset transform with its combined transform. 
   F = MC (M is the offset matrix and C is the combined matrix)
   
Then the final position v′of any vertex v can be calculated with: (Page 14 eq near top)


----


Any new animated transformation on the bone has to be multiplied by the inverse of the bindpose matrix

